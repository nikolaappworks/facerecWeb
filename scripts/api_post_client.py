
"""
API GET Client Script
Jednostavna skripta za pozivanje GET API endpoint-a sa procesiranjem ƒçlanaka
"""

import requests
import json
import sys
import argparse
import os
import re
from typing import Dict, Any, Set, List
from datetime import datetime
import pandas as pd

# Dodajemo putanju do app modula
app_path = os.path.join(os.path.dirname(__file__), '..')
sys.path.append(app_path)
print(f"üîß Dodata putanja: {app_path}")


def sanitize_domain_for_filename(domain: str) -> str:
    """Konvertuje domain u sigurno ime fajla"""
    # Uklanjamo protokol (http://, https://)
    domain = re.sub(r'^https?://', '', domain)
    # Zamenjujemo taƒçke i specijalne karaktere sa underscore
    domain = re.sub(r'[^a-zA-Z0-9]', '_', domain)
    # Uklanjamo vi≈°estruke underscore-ove
    domain = re.sub(r'_+', '_', domain)
    # Uklanjamo leading/trailing underscore
    domain = domain.strip('_')
    return domain


def get_domain_folder(domain: str) -> str:
    """Generi≈°e ime foldera za domain"""
    sanitized_domain = sanitize_domain_for_filename(domain)
    return os.path.join("storage", "mpanel", sanitized_domain)


def ensure_domain_folder_exists(domain: str) -> str:
    """Kreira folder za domain ako ne postoji i vraƒáa putanju"""
    folder_path = get_domain_folder(domain)
    os.makedirs(folder_path, exist_ok=True)
    return folder_path


def get_processed_ids_filename(domain: str) -> str:
    """Generi≈°e ime fajla za obraƒëene ID-jeve na osnovu domain-a"""
    return "processed_ids.json"


def get_page_counter_filename(domain: str) -> str:
    """Generi≈°e ime fajla za page brojaƒç na osnovu domain-a"""
    return "page_counter.json"


def load_page_counter(domain: str) -> int:
    """Uƒçitava trenutni page broj za domain"""
    folder_path = ensure_domain_folder_exists(domain)
    filename = get_page_counter_filename(domain)
    filepath = os.path.join(folder_path, filename)
    
    try:
        if os.path.exists(filepath):
            with open(filepath, 'r', encoding='utf-8') as f:
                data = json.load(f)
                return data.get('current_page', 1)
        return 1
    except Exception as e:
        print(f"‚ö†Ô∏è Gre≈°ka pri uƒçitavanju page brojaƒça: {e}")
        return 1


def save_page_counter(domain: str, page: int) -> None:
    """ƒåuva trenutni page broj za domain"""
    folder_path = ensure_domain_folder_exists(domain)
    filename = get_page_counter_filename(domain)
    filepath = os.path.join(folder_path, filename)
    
    try:
        data = {
            'current_page': page,
            'last_updated': datetime.now().isoformat(),
            'domain': domain
        }
        
        with open(filepath, 'w', encoding='utf-8') as f:
            json.dump(data, f, indent=2, ensure_ascii=False)
            
        print(f"üìÑ Page brojaƒç a≈æuriran: {page}")
        
    except Exception as e:
        print(f"‚ùå Gre≈°ka pri ƒçuvanju page brojaƒça: {e}")


def increment_page_counter(domain: str) -> int:
    """Poveƒáava page brojaƒç za domain i ƒçuva ga"""
    current_page = load_page_counter(domain)
    next_page = current_page + 1
    save_page_counter(domain, next_page)
    return next_page


def reset_page_counter(domain: str) -> None:
    """Resetuje page brojaƒç na 1"""
    save_page_counter(domain, 1)
    print(f"üîÑ Page brojaƒç resetovan na 1 za domain: {domain}")


def show_page_counter(domain: str) -> None:
    """Prikazuje trenutni page brojaƒç"""
    current_page = load_page_counter(domain)
    print(f"üìÑ Trenutni page za {domain}: {current_page}")


def load_processed_ids(domain: str) -> Set[int]:
    """Uƒçitava ID-jeve obraƒëenih ƒçlanaka iz JSON fajla"""
    folder_path = ensure_domain_folder_exists(domain)
    filename = get_processed_ids_filename(domain)
    filepath = os.path.join(folder_path, filename)
    
    try:
        if os.path.exists(filepath):
            with open(filepath, 'r', encoding='utf-8') as f:
                data = json.load(f)
                return set(data)
        return set()
    except Exception as e:
        print(f"‚ö†Ô∏è Gre≈°ka pri uƒçitavanju obraƒëenih ID-jeva: {e}")
        return set()


def save_processed_ids(processed_ids: Set[int], domain: str) -> None:
    """ƒåuva ID-jeve obraƒëenih ƒçlanaka u JSON fajl u domain folder-u"""
    folder_path = ensure_domain_folder_exists(domain)
    filename = get_processed_ids_filename(domain)
    filepath = os.path.join(folder_path, filename)
    
    try:
        with open(filepath, 'w', encoding='utf-8') as f:
            json.dump(list(processed_ids), f, indent=2, ensure_ascii=False)
            
        print(f"üíæ Obraƒëeni ID-jevi saƒçuvani u: {folder_path}/{filename}")
        
    except Exception as e:
        print(f"‚ùå Gre≈°ka pri ƒçuvanju obraƒëenih ID-jeva: {e}")


def ensure_excel_folder_exists() -> str:
    """Kreira folder za Excel fajlove ako ne postoji"""
    excel_folder = os.path.join("storage", "excel")
    os.makedirs(excel_folder, exist_ok=True)
    return excel_folder


def get_excel_filepath() -> str:
    """Vraƒáa putanju do Excel fajla"""
    excel_folder = ensure_excel_folder_exists()
    return os.path.join(excel_folder, "mpanel_persons.xlsx")


def load_existing_persons() -> pd.DataFrame:
    """Uƒçitava postojeƒáe osobe iz Excel fajla"""
    filepath = get_excel_filepath()
    
    try:
        if os.path.exists(filepath):
            df = pd.read_excel(filepath)
            print(f"üìä Uƒçitano {len(df)} postojeƒáih osoba iz Excel-a")
            return df
        else:
            # Kreiraj novi DataFrame sa potrebnim kolonama
            df = pd.DataFrame(columns=['name', 'last_name', 'number_of_repeat'])
            print("üìä Kreiran novi Excel fajl")
            return df
    except Exception as e:
        print(f"‚ö†Ô∏è Gre≈°ka pri uƒçitavanju Excel-a: {e}")
        # Kreiraj novi DataFrame u sluƒçaju gre≈°ke
        return pd.DataFrame(columns=['name', 'last_name', 'number_of_repeat'])


def save_persons_to_excel(df: pd.DataFrame) -> None:
    """ƒåuva DataFrame u Excel fajl"""
    try:
        filepath = get_excel_filepath()
        df.to_excel(filepath, index=False)
        print(f"üíæ Osobe saƒçuvane u: {filepath}")
    except Exception as e:
        print(f"‚ùå Gre≈°ka pri ƒçuvanju Excel-a: {e}")


def split_full_name(full_name: str) -> tuple:
    """Razdvaja puno ime na ime i prezime"""
    words = full_name.strip().split()
    if len(words) >= 2:
        # Prva reƒç je ime, sve ostale reƒçi su prezime
        first_name = words[0]
        last_name = ' '.join(words[1:])
        return first_name, last_name
    else:
        return full_name, ""


def add_persons_to_excel(filtered_names: List[str]) -> None:
    """Dodaje nove osobe u Excel fajl ili poveƒáava broj ponavljanja"""
    if not filtered_names:
        return
    
    # Uƒçitaj postojeƒáe osobe
    df = load_existing_persons()
    
    # Brojaƒç novih i a≈æuriranih osoba
    new_persons = 0
    updated_persons = 0
    
    for full_name in filtered_names:
        first_name, last_name = split_full_name(full_name)
        
        # Proveri da li osoba veƒá postoji
        existing_person = df[(df['name'] == first_name) & (df['last_name'] == last_name)]
        
        if existing_person.empty:
            # Dodaj novu osobu
            new_row = pd.DataFrame({
                'name': [first_name],
                'last_name': [last_name],
                'number_of_repeat': [1]
            })
            df = pd.concat([df, new_row], ignore_index=True)
            new_persons += 1
            print(f"‚ûï Dodata nova osoba: {first_name} {last_name}")
        else:
            # Poveƒáaj broj ponavljanja
            index = existing_person.index[0]
            df.at[index, 'number_of_repeat'] += 1
            updated_persons += 1
            print(f"üîÑ Poveƒáan broj ponavljanja za: {first_name} {last_name} (sada: {df.at[index, 'number_of_repeat']})")
    
    # Saƒçuvaj a≈æurirani Excel
    save_persons_to_excel(df)
    
    print(f"üìä Rezultat: {new_persons} novih osoba, {updated_persons} a≈æuriranih osoba")


def process_article(article: Dict[str, Any]) -> Dict[str, Any]:
    """
    Procesira pojedinaƒçni ƒçlanak
    
    Args:
        article (dict): Podaci o ƒçlanku
        
    Returns:
        dict: Rezultat procesiranja
    """
    article_id = article.get('id')
    title = article.get('title', 'Bez naslova')
    content = article.get('contents', 'Bez sadr≈æaja')
    
    
    # OVDE DODAJTE VA≈†U LOGIKU ZA PROCESIRANJE ƒåLANKA
    # ================================================
    try:
        # Uvoz OpenAIService
        from app.services.openai_service import OpenAIService
                    
        # Inicijalizacija OpenAI servisa
        openai_service = OpenAIService()
        
        # Priprema parametara za API poziv
        schema = openai_service.get_human_names_schema()
        messages = [
            {
                "role": "system",
                "content": """You are a strict entity extraction assistant. Your task is to extract only **real, notable people** mentioned in the provided text.

                RULES:
                1. Only extract names of **real, famous individuals**.
                2. You must return only **full names**, meaning both **first name and last name** must be present.
                - Do NOT return partial names.
                - Do NOT return only a surname or only a given name.
                - Do NOT return initials (e.g., "S.T." or "Stefan T.").
                3. All names must be returned strictly in **nominative case** (the base grammatical form of the name, e.g., "Stefan Tomiƒá", not "Stefanu Tomiƒáu").
                4. If a person is mentioned multiple times in the text (including in different grammatical forms or spellings), include them **only once**, using their nominative form.
                5. Only include real people, not fictional characters, organizations, or other entities.

                OUTPUT FORMAT:
                - Return a JSON array of strings with full names in nominative form.
                - Example: ["Angela Merkel", "Elon Musk"]
                - If there are no valid full names, return an empty list: []

                EXAMPLES (valid):
                ‚úÖ "Angela Merkel"
                ‚úÖ "Elon Musk"
                ‚úÖ "Stefan Tomiƒá"

                EXAMPLES (invalid, must be excluded):
                ‚ùå "Merkel"
                ‚ùå "Stefan T."
                ‚ùå "S.T."
                ‚ùå "Stefanu Tomiƒáu" (must be converted to "Stefan Tomiƒá")
                ‚ùå "Ministar zdravlja"
                """
            },
            {
                "role": "user",
                "content": [
                    { "type": "text", "text": f"Text: {content}" }
                ]
            }
        ]
        
        # Poziv OpenAI API-ja
        response = openai_service.safe_openai_request(
            model="gpt-4.1",  # Koristite model koji je dostupan
            messages=messages,
            temperature=0.3,
            max_tokens=2100,
            functions=[schema],
            function_call={"name": "get_human_names"}
        )
        
        # Obrada odgovora
        if response.choices and response.choices[0].message.function_call:
            function_call = response.choices[0].message.function_call
            arguments = json.loads(function_call.arguments)
            print(f"Response: {json.dumps(arguments, ensure_ascii=False, indent=4)}")
            
            # Provera da li je osoba stvarna
            names = arguments.get('names', [])
            
            # Filtriranje imena - uklanjamo imena sa jednom reƒçju ili reƒçima sa manje od 3 slova
            filtered_names = []
            for name in names:
                # Razdvajamo ime na reƒçi
                words = name.strip().split()
                
                # Proveravamo da li ima vi≈°e od jedne reƒçi
                if len(words) < 2:
                    print(f"‚ùå Uklanjam '{name}' - ima samo {len(words)} reƒç")
                    continue
                
                # Proveravamo da li svaka reƒç ima bar 3 slova
                valid_words = True
                for word in words:
                    if len(word) < 3:
                        print(f"‚ùå Uklanjam '{name}' - reƒç '{word}' ima manje od 3 slova")
                        valid_words = False
                        break
                
                if valid_words:
                    filtered_names.append(name)
                    print(f"‚úÖ Zadr≈æavam '{name}' - validno ime")
            
            if filtered_names:
                print(f"‚úÖ Konaƒçne stvarne osobe: {filtered_names}")
                # ƒåuvamo osobe u Excel fajl
                add_persons_to_excel(filtered_names)
            else:
                print(f"‚ùå Nisu pronaƒëene validne stvarne osobe u ƒçlanku.")

            
    except ImportError as e:
        print(f"‚ùå Gre≈°ka pri import-u modula: {str(e)}")
        print("Proverite da li je app modul dostupan")
    except Exception as e:
        print(f"‚ùå Gre≈°ka prilikom obrade ƒçlanka: {str(e)}")
    # Primer procesiranja - mo≈æete prilagoditi prema va≈°im potrebama
    processed_data = {
        'id': article_id,
        'title': title,
        'intro': article.get('intro'),
        'publish_date': article.get('publish_date'),
        'url': article.get('url'),
        'categories': [cat.get('name') for cat in article.get('categories', [])],
        'tags': [tag.get('name') for tag in article.get('tags', [])],
        'featured_image': article.get('featured_image'),
        'processed_at': datetime.now().isoformat(),
        'status': 'processed'
    }
    
    # Dodatna obrada - mo≈æete dodati svoju logiku ovde
    # processed_data['custom_field'] = your_custom_processing(article)
    
    # ================================================
    
    return processed_data


def process_articles_from_response(api_response: Dict[str, Any], domain: str) -> Dict[str, Any]:
    """
    Procesira sve ƒçlanke iz API odgovora
    
    Args:
        api_response (dict): Odgovor od API-ja
        domain (str): Domain URL za generisanje imena fajla
        
    Returns:
        dict: Statistika procesiranja
    """
    if api_response.get('status') != 'success':
        print("‚ùå API odgovor nije uspe≈°an, preskaƒçem procesiranje")
        return {'error': 'API response not successful'}
    
    # Uƒçitavamo obraƒëene ID-jeve
    processed_ids = load_processed_ids(domain)
    
    # Izvlaƒçimo ƒçlanke iz odgovora
    data = api_response.get('data', {})
    result = data.get('result', {})
    articles = result.get('articles', [])
    
    if not articles:
        print("‚ÑπÔ∏è Nema ƒçlanaka za procesiranje")
        return {'processed': 0, 'skipped': 0, 'total': 0}
    
    print(f"üìö Pronaƒëeno {len(articles)} ƒçlanaka")
    print(f"üìä Trenutno obraƒëeno ƒçlanaka: {len(processed_ids)}")
    
    processed_count = 0
    skipped_count = 0
    
    for article in articles:
        article_id = article.get('id')
        
        if not article_id:
            print("‚ö†Ô∏è ƒålanak bez ID-ja, preskaƒçem")
            continue
        
        if article_id in processed_ids:
            print(f"‚è≠Ô∏è ƒålanak {article_id} veƒá obraƒëen, preskaƒçem")
            skipped_count += 1
            continue
        
        # Procesiranje ƒçlanka
        try:
            processed_article = process_article(article)
            
            # Dodajemo ID u listu obraƒëenih
            processed_ids.add(article_id)
            processed_count += 1
            
            # OVDE MO≈ΩETE DODATI ƒåUVANJE REZULTATA PROCESIRANJA
            # ==================================================
            # Primer: ƒåuvanje u zaseban fajl
            # with open(f"article_{article_id}.json", 'w', encoding='utf-8') as f:
            #     json.dump(processed_article, f, indent=2, ensure_ascii=False)
            # ==================================================
            
        except Exception as e:
            print(f"‚ùå Gre≈°ka pri procesiranju ƒçlanka {article_id}: {e}")
    
    # ƒåuvamo a≈æuriranu listu obraƒëenih ID-jeva
    save_processed_ids(processed_ids, domain)
    
    return {
        'processed': processed_count,
        'skipped': skipped_count,
        'total': len(articles),
        'total_processed_ids': len(processed_ids)
    }


def call_api_endpoint(domain: str, header_value: str, article_limit: int = 25, page: int = 1, data: Dict[str, Any] = None) -> Dict[str, Any]:
    """
    Poziva GET API endpoint na prosleƒëenom domain-u
    
    Args:
        domain (str): Domain URL (npr. 'https://api.example.com')
        header_value (str): Vrednost za header
        article_limit (int): Broj artikala (default: 25)
        page (int): Broj stranice (default: 1)
        data (dict): Podaci za slanje (opciono)
        
    Returns:
        dict: Odgovor od API-ja
    """
    # Uklanjamo trailing slash iz domain-a
    domain = domain.rstrip('/')
    
    # Fiksni endpoint sa query parametrima
    endpoint = f"/api/webV2/getArticles?articleLimit={article_limit}&page={page}"
    url = f"{domain}{endpoint}"
    
    # Default podaci ako nisu prosleƒëeni
    if data is None:
        data = {
            "message": "Test request",
            "timestamp": "2024-01-01T00:00:00Z"
        }
    
    # Headers sa prosleƒëenim header-om
    headers = {
        'Content-Type': 'application/json',
        'User-Agent': 'FaceRecognitionWeb-APIClient/1.0',
        'Authorization': header_value  # Dodajemo prosleƒëeni header
    }
    
    try:
        print(f"üåê Pozivanje: {url}")
        print(f"üîë Header: Authorization: {header_value}")
        
        # Izvr≈°avanje GET zahteva
        response = requests.get(url, json=data, headers=headers, timeout=30)
        
        # Proveravamo status kod
        response.raise_for_status()
        
        # Poku≈°avamo da parsijemo JSON odgovor
        try:
            result = response.json()
            return {
                'status': 'success',
                'status_code': response.status_code,
                'data': result,
                'message': 'Uspe≈°no pozvan API endpoint'
            }
        except json.JSONDecodeError:
            return {
                'status': 'success',
                'status_code': response.status_code,
                'data': response.text,
                'message': 'Odgovor nije JSON format'
            }
            
    except requests.exceptions.RequestException as e:
        return {
            'status': 'error',
            'error': str(e),
            'message': f'Gre≈°ka pri komunikaciji sa API-jem: {e}'
        }


def display_response(response: Dict[str, Any]) -> None:
    """
    Prikazuje odgovor od API-ja
    
    Args:
        response (dict): Odgovor od API-ja
    """
    print("\n" + "="*50)
    print("ODGOVOR OD API-JA")
    print("="*50)
    
    if response.get('status') == 'error':
        print(f"‚ùå GRE≈†KA: {response.get('message', 'Nepoznata gre≈°ka')}")
        if 'error' in response:
            print(f"Detalji: {response['error']}")
    else:
        print("‚úÖ USPE≈†NO")
        print(f"Status kod: {response.get('status_code', 'N/A')}")
        print(f"Poruka: {response.get('message', 'N/A')}")
        
    
    print("="*50 + "\n")


def main():
    """Glavna funkcija skripte"""
    parser = argparse.ArgumentParser(description='API GET Client sa procesiranjem ƒçlanaka')
    parser.add_argument('domain', help='Domain URL (npr. https://api.example.com)')
    parser.add_argument('--header', required=True, help='Vrednost za Authorization header')
    parser.add_argument('--article-limit', type=int, default=25, help='Broj artikala (default: 25)')
    parser.add_argument('--page', type=int, help='Broj stranice (opciono - ako nije prosleƒëen, koristi se automatski)')
    parser.add_argument('--data', help='JSON podaci za slanje (opciono)')
    parser.add_argument('--reset-page', action='store_true', help='Resetuje page brojaƒç na 1')
    parser.add_argument('--show-page', action='store_true', help='Prikazuje trenutni page brojaƒç')
    
    args = parser.parse_args()
    
    # Specijalne komande
    if args.reset_page:
        reset_page_counter(args.domain)
        return
    
    if args.show_page:
        show_page_counter(args.domain)
        return
    
    # Parsiranje JSON podataka ako su prosleƒëeni
    data = None
    if args.data:
        try:
            data = json.loads(args.data)
        except json.JSONDecodeError as e:
            print(f"‚ùå Gre≈°ka pri parsiranju JSON podataka: {e}")
            sys.exit(1)
    
    # Odreƒëivanje page broja
    if args.page is not None:
        # Ako je prosleƒëen page, koristimo ga
        page = args.page
        print(f"üìÑ Kori≈°ƒáen prosleƒëeni page: {page}")
    else:
        # Ako nije prosleƒëen, uƒçitavamo automatski page
        page = load_page_counter(args.domain)
        print(f"üìÑ Automatski uƒçitavan page: {page}")
    
    # Pozivanje API endpoint-a
    response = call_api_endpoint(args.domain, args.header, args.article_limit, page, data)
    
    # Prikazivanje odgovora
    display_response(response)
    
    # Procesiranje ƒçlanaka
    print("\n" + "="*50)
    print("PROCESIRANJE ƒåLANAKA")
    print("="*50)
    
    stats = process_articles_from_response(response, args.domain)
    
    # Prikazivanje statistike
    print("\n" + "="*50)
    print("STATISTIKA PROCESIRANJA")
    print("="*50)
    
    if 'error' in stats:
        print(f"‚ùå Gre≈°ka: {stats['error']}")
    else:
        print(f"‚úÖ Obraƒëeno: {stats['processed']}")
        print(f"‚è≠Ô∏è Preskoƒçeno: {stats['skipped']}")
        print(f"üìö Ukupno u odgovoru: {stats['total']}")
        print(f"üìä Ukupno obraƒëeno ƒçlanaka: {stats['total_processed_ids']}")
        
        # Ako je bilo obraƒëenih ƒçlanaka, poveƒáavamo page brojaƒç
        if stats['processed'] > 0:
            next_page = increment_page_counter(args.domain)
            print(f"üìÑ Page brojaƒç poveƒáan na: {next_page}")
    
    print("="*50 + "\n")


if __name__ == "__main__":
    main() 